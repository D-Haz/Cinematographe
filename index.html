<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Total Role Call</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @keyframes gradientFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .gradient-bg {
            background: linear-gradient(-45deg, #FF0080, #7928CA, #FF4D4D, #0070F3);
            background-size: 400% 400%;
            animation: gradientFlow 15s ease infinite;
        }
        
        .glassmorphism {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .link {
            stroke: rgba(255, 255, 255, 0.3);
            stroke-dasharray: 5;
            animation: dash 20s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: 1000;
            }
        }
    </style>
</head>
<body class="gradient-bg min-h-screen text-white overflow-x-hidden">
    <div class="container mx-auto p-4">
        <!-- Title Section -->
        <div class="text-center mb-8 relative">
            <div class="absolute -top-10 left-1/2 -translate-x-1/2 w-96 h-96 bg-purple-500 rounded-full filter blur-[100px] opacity-20"></div>
            <h1 class="text-6xl font-black tracking-tighter mb-2 relative">
                <span class="bg-clip-text text-transparent bg-gradient-to-r from-white to-purple-200">
                    The Big Pictures
                </span><br/>
                <span class="bg-clip-text text-transparent bg-gradient-to-r from-white to-purple-200 text-lg">
                    Have fun Mein Schatz
                </span>
            </h1>
        </div>

        <!-- Search Bar -->
        <div class="flex justify-center mb-8 relative">
            <input id="search-bar" type="text" 
                placeholder="Search movies, actors, or directors..."
                class="w-2/3 glassmorphism rounded-full px-8 py-4 text-lg focus:outline-none focus:ring-2 focus:ring-white/50 placeholder-white/50">
            <button id="search-button" 
                class="absolute right-[17%] top-1/2 -translate-y-1/2 px-6 py-2 rounded-full bg-white/10 hover:bg-white/20 transition-all">
                Search
            </button>
        </div>

        <!-- Graph Container -->
        <div id="graph-container" class="glassmorphism rounded-3xl h-[70vh] mb-8 relative overflow-hidden">
            <div class="absolute top-4 right-4 flex space-x-2 z-10">
                <button id="zoom-in" class="p-3 glassmorphism rounded-full hover:bg-white/10 transition-all">+</button>
                <button id="zoom-out" class="p-3 glassmorphism rounded-full hover:bg-white/10 transition-all">-</button>
                <button id="reset-view" class="p-3 glassmorphism rounded-full hover:bg-white/10 transition-all">â†º</button>
            </div>
            <svg id="graph-svg"></svg>
        </div>

        <!-- Action Buttons -->
        <div class="flex justify-center space-x-6 mb-8">
            <button id="verify-button" 
                class="px-8 py-3 glassmorphism rounded-full hover:bg-white/10 transition-all">
                Verify Connections
            </button>
            <button id="clear-button"
                class="px-8 py-3 glassmorphism rounded-full hover:bg-white/10 transition-all">
                Clear Board
            </button>
            <button id="restart-button"
                class="px-8 py-3 glassmorphism rounded-full hover:bg-white/10 transition-all">
                Restart Game
            </button>
        </div>
        <iframe width="100%" height="auto" src="https://www.livehdtv.com/embed/bbc-one/" frameborder="0"  scrolling="no"></iframe>
    
        <!-- Search Results -->
        <div id="results" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6"></div>

        <!-- Context Menu -->
        <div id="context-menu" class="hidden absolute glassmorphism rounded-xl z-50 overflow-hidden">
            <ul>
                <li class="px-6 py-3 hover:bg-white/10 cursor-pointer" id="connect-node">Connect</li>
                <li class="px-6 py-3 hover:bg-white/10 cursor-pointer" id="delete-node">Delete</li>
            </ul>
        </div>
    </div>

    <script>
        const TMDB_API_KEY = "dc90ecfc8713216c67ff4170bbb02591";

        let nodes = [];
        let links = [];
        let selectedNode = null;
        let connecting = false;

        const svg = d3.select("#graph-svg")
            .attr("width", "100%")
            .attr("height", "100%");

        // Initialize zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.2, 2])
            .on("zoom", (event) => {
                container.attr("transform", event.transform);
            });

        svg.call(zoom);
        const container = svg.append("g");

        const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(150))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2))
            .on("tick", ticked);

        // New function to fetch a random popular actor
        async function getRandomPopularActor() {
            console.log("Fetching random popular actor...");
            const response = await fetch(`https://api.themoviedb.org/3/person/popular?api_key=${TMDB_API_KEY}&language=en-US&page=${Math.floor(Math.random() * 10) + 1}`);
            const data = await response.json();
            const nonAdultActors = data.results.filter(actor => !actor.adult); // Filter out adult actors
            if (nonAdultActors.length === 0) {
                console.log("No non-adult actors found.");
                return null;
            }
            const randomIndex = Math.floor(Math.random() * nonAdultActors.length);
            console.log("Fetched actors:", nonAdultActors);
            return nonAdultActors[randomIndex];
        }

        async function startGame() {
            // Clear existing nodes and links
            nodes = [];
            links = [];
            updateGraph();

            // Fetch two random popular actors
            const actor1 = await getRandomPopularActor();
            const actor2 = await getRandomPopularActor();

            if (actor1) {
                console.log("Selected actor 1:", actor1.name);
                const randomActorNode1 = {
                    id: actor1.id,
                    type: 'person',
                    label: actor1.name,
                    image: `https://image.tmdb.org/t/p/w92${actor1.profile_path}`
                };
                // Add the first selected random actor as a node
                addNode(randomActorNode1);
                console.log("Added actor 1 to graph:", randomActorNode1);
            } else {
                console.log("No actor 1 found.");
            }

            if (actor2) {
                console.log("Selected actor 2:", actor2.name);
                const randomActorNode2 = {
                    id: actor2.id,
                    type: 'person',
                    label: actor2.name,
                    image: `https://image.tmdb.org/t/p/w92${actor2.profile_path}`
                };
                // Add the second selected random actor as a node
                addNode(randomActorNode2);
                console.log("Added actor 2 to graph:", randomActorNode2);
            } else {
                console.log("No actor 2 found.");
            }

            updateGraph();
        }

        async function fetchResults(query) {
            const url = `https://api.themoviedb.org/3/search/multi?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}`;
            const response = await fetch(url);
            const data = await response.json();
            return data.results;
        }

        function renderResults(results) {
            const resultsContainer = document.getElementById('results');
            resultsContainer.innerHTML = '';
            results.forEach(item => {
                if (!item.poster_path && !item.profile_path) return;
                
                const resultCard = document.createElement('div');
                resultCard.classList.add('glassmorphism', 'rounded-xl', 'p-4', 'hover:bg-white/10', 'transition-all');
                resultCard.innerHTML = `
                    <div class="flex items-center space-x-4">
                        <img src="https://image.tmdb.org/t/p/w92${item.poster_path || item.profile_path}" 
                            alt="${item.title || item.name}"
                            class="w-16 h-16 rounded-lg object-cover">
                        <div class="flex-1">
                            <h3 class="font-medium">${item.title || item.name}</h3>
                            <p class="text-sm opacity-70">${item.media_type}</p>
                        </div>
                        <button class="add-button px-4 py-2 rounded-full glassmorphism hover:bg-white/10 transition-all"
                            data-id="${item.id}" 
                            data-type="${item.media_type}" 
                            data-label="${item.title || item.name}" 
                            data-image="${item.poster_path || item.profile_path}">
                            Add
                        </button>
                    </div>
                `;
                resultsContainer.appendChild(resultCard);
            });
        }

        let lastNodePosition = { x: window.innerWidth / 2, y: window.innerHeight / 2 }; // Initial position

        function addNode(item) {
            // Check for duplicate nodes
            const existingNode = nodes.find(node => node.id === item.id);
            if (existingNode) {
                console.log(`Node with ID ${item.id} already exists. Skipping addition.`);
                return; // Skip adding the node if it already exists
            }

            // Set the position of the new node close to the last node
            item.x = lastNodePosition.x + (Math.random() - 0.5) * 100; // Random offset
            item.y = lastNodePosition.y + (Math.random() - 0.5) * 100; // Random offset

            nodes.push(item);
            lastNodePosition = { x: item.x, y: item.y }; // Update last node position
            console.log("Node added:", item);
            updateGraph();
        }

        function addLink(source, target) {
            // Check for duplicate connections
            const existingLink = links.find(link => 
                (link.source.id === source.id && link.target.id === target.id) ||
                (link.source.id === target.id && link.target.id === source.id)
            );

            if (existingLink) {
                console.log(`Connection between ${source.label} and ${target.label} already exists. Skipping addition.`);
                return; // Skip adding the link if it already exists
            }

            links.push({ source, target });
            console.log("Link added between:", source.label, "and", target.label);
            updateGraph();
        }

        function updateGraph() {
            // Links
            const link = container.selectAll(".link")
                .data(links)
                .join(
                    enter => enter.append("line")
                        .attr("class", "link")
                );

            // Nodes
            const nodeGroups = container.selectAll(".node-group")
                .data(nodes, d => d.id)
                .join(
                    enter => {
                        const group = enter.append("g")
                            .attr("class", "node-group")
                            .call(d3.drag()
                                .on("start", dragstarted)
                                .on("drag", dragged)
                                .on("end", dragended));

                        group.append("circle")
                            .attr("r", 30)
                            .attr("fill", "rgba(255, 255, 255, 0.1)")
                            .attr("stroke", "rgba(255, 255, 255, 0.3)")
                            .attr("stroke-width", 1);

                        group.append("image")
                            .attr("xlink:href", d => d.image)
                            .attr("x", -20)
                            .attr("y", -20)
                            .attr("width", 40)
                            .attr("height", 40)
                            .attr("clip-path", "circle(20px at center)");

                        group.append("text")
                            .attr("x", 40)
                            .attr("y", 5)
                            .text(d => d.label)
                            .attr("fill", "white")
                            .attr("font-size", "12px");

                        group.on("contextmenu", (event, d) => {
                            event.preventDefault();
                            showContextMenu(event, d);
                        });

                        return group;
                    }
                );

            // Update simulation
            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
        }

        function ticked() {
            // Update link positions
            container.selectAll(".link")
                .attr("x1", d => d.source?.x || 0)
                .attr("y1", d => d.source?.y || 0)
                .attr("x2", d => d.target?.x || 0)
                .attr("y2", d => d.target?.y || 0);

            // Update node positions
            container.selectAll(".node-group")
                .attr("transform", d => `translate(${d?.x || 0},${d?.y || 0})`);
        }

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function showContextMenu(event, node) {
            selectedNode = node;
            const menu = document.getElementById("context-menu");
            menu.style.top = `${event.pageY}px`;
            menu.style.left = `${event.pageX}px`;
            menu.classList.remove("hidden");
        }

        async function verifyConnections() {
            for (const link of links) {
                const source = nodes.find(node => node.id === link.source.id);
                const target = nodes.find(node => node.id === link.target.id);
                
                if ((source.type === 'movie' && target.type === 'person') || 
                    (source.type === 'person' && target.type === 'movie')) {
                    
                    const movieNode = source.type === 'movie' ? source : target;
                    const personNode = source.type === 'person' ? source : target;

                    try {
                        const creditsResponse = await fetch(`https://api.themoviedb.org/3/movie/${movieNode.id}/credits?api_key=${TMDB_API_KEY}`);
                        if (!creditsResponse.ok) throw new Error('Failed to fetch credits');
                        
                        const creditsData = await creditsResponse.json();
                        
                        const isValid = creditsData.cast.some(person => person.id === Number(personNode.id)) || 
                                        creditsData.crew.some(person => person.id === Number(personNode.id));
                        
                        if (!isValid) {
                            alert(`Invalid connection: ${movieNode.label} and ${personNode.label}`);
                            return;
                        }
                    } catch (error) {
                        console.error('Error:', error);
                        alert('Error validating connections');
                        return;
                    }
                }
            }
            alert('All connections are valid!');
        }

        // Event Listeners
        document.addEventListener("click", (event) => {
            const menu = document.getElementById("context-menu");
            if (!menu.contains(event.target)) {
                menu.classList.add("hidden");
            }
        });

        document.getElementById("connect-node").addEventListener("click", () => {
            connecting = true;

            // Create a temporary line
            const tempLine = container.append("line")
                .attr("class", "link")
                .attr("stroke", "rgba(255, 255, 255, 0.3)")
                .attr("stroke-width", 2)
                .attr("stroke-dasharray", "5");

            // Create a hit area (rectangle) for the line
            const hitArea = container.append("rect")
                .attr("class", "hit-area")
                .attr("fill", "transparent") // Make it invisible
                .attr("pointer-events", "all") // Ensure it captures pointer events
                .attr("width", 10) // Width of the hit area
                .attr("height", 10) // Height of the hit area
                .attr("x", 0) // Initial position
                .attr("y", 0); // Initial position

            svg.on("mousemove", (event) => {
                if (connecting) {
                    const [x, y] = d3.pointer(event);
                    const transform = d3.zoomTransform(svg.node());
                    const adjustedX = (x - transform.x) / transform.k;
                    const adjustedY = (y - transform.y) / transform.k;

                    tempLine
                        .attr("x1", selectedNode.x)
                        .attr("y1", selectedNode.y)
                        .attr("x2", adjustedX)
                        .attr("y2", adjustedY);

                    // Update the hit area position and size
                    hitArea
                        .attr("x", Math.min(selectedNode.x, adjustedX) - 5) // Center the hit area
                        .attr("y", Math.min(selectedNode.y, adjustedY) - 5) // Center the hit area
                        .attr("width", Math.abs(selectedNode.x - adjustedX) + 10) // Width based on line length
                        .attr("height", Math.abs(selectedNode.y - adjustedY) + 10); // Height based on line length
                }
            });

            svg.on("click", (event) => {
                const [x, y] = d3.pointer(event);
                const transform = d3.zoomTransform(svg.node());
                const adjustedX = (x - transform.x) / transform.k; // Adjust for zoom
                const adjustedY = (y - transform.y) / transform.k; // Adjust for zoom

                const targetNode = nodes.find(node => {
                    const dx = node.x - adjustedX;
                    const dy = node.y - adjustedY;
                    return Math.sqrt(dx * dx + dy * dy) < 30; // Check if the mouse is close to a node
                });

                if (connecting && targetNode && targetNode !== selectedNode) {
                    if ((selectedNode.type === 'person' && targetNode.type === 'movie') ||
                        (selectedNode.type === 'movie' && targetNode.type === 'person')) {
                        
                        // Add the link to the links array
                        addLink(selectedNode, targetNode);
                        
                        // Set the attributes of the temporary line to match the new link
                        tempLine
                            .attr("x1", selectedNode.x)
                            .attr("y1", selectedNode.y)
                            .attr("x2", targetNode.x)
                            .attr("y2", targetNode.y);
                    }
                }
                
                // Stop connecting
                connecting = false; // Reset connecting state
                svg.on("mousemove", null); // Remove mousemove event listener
                svg.on("click", null); // Remove click event listener
            });

            // Add double-click event listener to the hit area
            hitArea.on("dblclick", () => {
                // Remove the temporary line and hit area
                tempLine.remove();
                hitArea.remove();
                
                // Optionally, you can also remove the link if it was created
                links = links.filter(link => !(link.source === selectedNode && link.target === targetNode) &&
                                              !(link.source === targetNode && link.target === selectedNode));
                updateGraph(); // Update the graph to reflect the changes
            });
        });

        document.getElementById("delete-node").addEventListener("click", () => {
            nodes = nodes.filter(node => node !== selectedNode);
            links = links.filter(link => link.source !== selectedNode && link.target !== selectedNode);
            updateGraph();
            document.getElementById("context-menu").classList.add("hidden");
        });

        // Zoom control event listeners
        document.getElementById("zoom-in").addEventListener("click", () => {
            svg.transition().duration(500).call(zoom.scaleBy, 1.5);
        });

        document.getElementById("zoom-out").addEventListener("click", () => {
            svg.transition().duration(500).call(zoom.scaleBy, 0.75);
        });

        document.getElementById("reset-view").addEventListener("click", () => {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        });

        document.getElementById('search-button').addEventListener('click', async () => {
            const query = document.getElementById('search-bar').value;
            if (query) {
                const results = await fetchResults(query);
                renderResults(results);
            }
        });

        document.getElementById('search-bar').addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const query = e.target.value;
                if (query) {
                    const results = await fetchResults(query);
                    renderResults(results);
                }
            }
        });

        document.getElementById('results').addEventListener('click', event => {
            if (event.target.classList.contains('add-button')) {
                const id = event.target.dataset.id;
                const type = event.target.dataset.type;
                const label = event.target.dataset.label;
                const image = `https://image.tmdb.org/t/p/w92${event.target.dataset.image}`;
                addNode({ id, type, label, image });
            }
        });

        document.getElementById('clear-button').addEventListener('click', () => {
            nodes = [];
            links = [];
            updateGraph();
        });

        document.getElementById('restart-button').addEventListener('click', () => {
            startGame(); // Restart the game and fetch new actors
        });

        document.getElementById('verify-button').addEventListener('click', verifyConnections);

        // Handle window resize
        window.addEventListener('resize', () => {
            simulation.force("center", d3.forceCenter(
                document.getElementById('graph-container').clientWidth / 2,
                document.getElementById('graph-container').clientHeight / 2
            ));
            simulation.alpha(0.3).restart();
        });

        // Initialize the game
        startGame();
    </script>
</body>
</html>
